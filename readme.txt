# Αλγοριθμος ταξινομισης σε CHUNKS (για μεγαλα δεδομενα) 2023-2024

Σε αυτην την εργασια μας δυνονταν ετειμα καποια πραγματα και επρεπε να υλοποιησουμε τα εκτελεσημα με βασει τα headers.
  

Για την δημιουργία του εκτελέσιμου το οποίο δείχνει 
τις δυνατότητες της βιβλιοθήκης BF, τρέξτε την εντολή: 
make sort; 

 
Για να τρέξετε το εκτελέσιμο: 
./build/sort_main 

  
ΣΧΕΔΙΑΣΤΙΚΕΣ ΕΠΙΛΟΓΕΣ: 

  

SORT.c 

Η sorting συνάρτηση που χρησιμοποιήθηκε στην sort.c ειναι η bublesort. 

---------------------------------------------------------------------------- 

CHUNK.C 

Γενικά έχω φτιάξει μια global μεταβλητή απο CHUNKS(πίνακας απο CHUNKS) στο chunk.c όπως και μια μεταβλητή για το μέγεθος του πίνακά αν και Είναι κάκια πρακτικη να εχουμε global μεταβλητές το έκανα έτσι ώστε να μην μπορεί κάποιος να εχει πρόσβαση και να μπορεί να αλλάζει τα δεδομένα που εχω μεσα στα chunks 

  

---------------------------------------------------------------------------- 

MERGE.c 

Ακολουθήσαμε κατά γράμμα τον αλγόριθμο της διάλεξης 

--------------------------------------------------------------------------- 

  

Δεν υπάρχει καμία δυσλειτουργία. 

Το ελέγξαμε με 5000 εγγραφές και έτρεξε σωστά 

Η μονή δυσλειτουργία είναι ότι γραφεί μυνημα "λάθους" το οποίο είναι προγραμματισμένο απο εμας για ασφάλεια στην εκτέλεση. Μπορειτε να το αφαιρέσετε αν θέλετε. 


  

chunk.c and chunk.h: 

STRUCTS 

1.CHUNK το αφοισα οπος ηταν 

2.CHUNK_Iterator εδω αποθηκεύω το file descriptor και έναν ακέραιο που μου λέει σε πιο chunk βρίσκομαι 

  

FUNCTIONS 

1.Δικες μου 

α.void SetCHUNK(int from_BlockId,int to_BlockId,int recordsInChunk,int blocksInChunk,CHUNK *chunkModifed) 
Το μόνο που κάνει ειναι να αποθηκεύει στο CHUNK που του στέλνω τις μεταβλητές του 

  

β.int Arraysize(); 
Απλά επιστρέφει το ποσά chunks εχω φτιάξει 

  

γ:void Delete_Chunk_Array() 
Αποδεσμεύει τον χορό που εχω δεσμεύσει δυναμικά για τον πίνακα με τα chunks(πρέπει να καλείτε πάντα πριν το τέλος του προγράμματος για αποφύγει memory leaks) 

  

2.Προηπαρχουσες 

α.CHUNK_Iterator CHUNK_CreateIterator(int fileDesc, int blocksInChunk); 
Αρχικά βρισκω ακριβός ποσά CHUNKS θα χρειαστώ. Αρχικοποιο τις μεταβλητές του CHUNK ITERATOR και μετα αποδεσμεύω τυχόν χορο που ειχα δέσμευση πιο παλιά για τα CHUNKS και μετα δεσμεύω οσο χρειαζομαι.Αρχικοποιο καθε ενα CHUNK ξεχωριστά. Για το τελευταίο εχει ειδική μεταχείριση. 

  

β.int CHUNK_GetNext(CHUNK_Iterator *iterator,CHUNK* chunk); 
Έλεγχο για αρχή αν βρίσκομαι είδη στο τελευταίο CHUNK του γράφω ενα μήνυμα λάθους και επιστρέφω 1(αποτυχία) και έχει απλά το τελευταίο CHUNK ξανά στα χερια του. Αλλιώς αντίγραφο τα δεδομένα και τα επιστρέφω στο τέλος αλλάζω την μεταβλητή για τον επόμενο CHUNK ( ουσιαστικα στην πρώτη κλήση αυτη η συνάρτηση επιστρέφει τα δεδωμενα του CHUNK[0]) και 0(επιτυχία).(άμα χεριάζετε το μήνυμα μπορεί να γίνει σχόλιο) 

  

γ.CHUNK_RecordIterator CHUNK_CreateRecordIterator(CHUNK *chunk); 
Φτιάχνω ενα iterator και το αρχικοποιο με τα δεδομενα που μου στελνει για το συγκεκριμένο CHUNK 

  

δ.int CHUNK_GetNextRecord(CHUNK_RecordIterator *iterator,Record* record); 
Έλεγχο αν η εγγραφή που μου ζητάει να επιστρέψω υπαρχει, δηλαδή αν πχ υπάρχουν 50 και μου ζητάει την εγγραφή πάνω απο 51,αλιος του επιστρέφω την επόμενη εγγραφή η οποία είναι η τελευταίο απο την προηγουμένη φορα (δηλαδή την πρώτη φορά που την καν  να επιστρέφει την πρώτη  - προτη εγγραφή).Επιστρέφει 1 για fail 0 για sucess. 

  

ε.void CHUNK_Print(CHUNK chunk); 
Φτιάχνω έναν Record Iterator για να εχω μια εύκολη πρόσβαση στης εγγραφής του CHUNK, εκτυπώνω κάποια δεδομένα για το CHUNK και μετα εκτυπώνω με ενα κομψό τροπο τις εγγραφές του CHUNK 


ζ.int CHUNK_GetIthRecordInChunk(CHUNK* chunk, int i, Record* record) 
Εαν η εγγραφή που θέλει ειναι εκτος απο της εγγραφες του chunk π.χ (την -1 εγγραφή η την 41 αν υπάρχουν μονο 40 )τοτε του γραφω ενα μυνημα λαθους(αυτο μπορει να γινει σχολιο )και επιστρέφει 1 (fail) 
Αλλιώς βρίσκουμε πιο ειναι το block id μεσα στο chunk το οποιο εχει την συγκεκριμένη εγγραφή , το συγκεκριμένο block βρίσκουμε σε πια σειρά βρίσκετε η εγγραφή παμε και την περνούμε απο το block και μετα το κανουμε unpin και επιστρέφουμε 0 (sucess) 


η.int CHUNK_UpdateIthRecord(CHUNK* chunk, int i, Record record) 
Ακριβώς η ιδια με την CHUNK_GetIthRecordInChunk με την διαφορά οτι αντι για να παρω την εγγραφη την ανανεώνω 

-------------------------------------------------------------------------------------------------------------------- 

  

sort.c 


shouldSwap 
Στην shouldSwap ελέγχω αν δυο έγγραφες χρειάζεται να ανταλλαχτούν κατά την διάρκεια της ταξινόμησης. 
Χρησιμοποιώντας την strcmp(rec1->name, rec2->name) ελέγχω αν τα ονόματα είναι ίδια 
Αν είναι τότε συγκρίνω επώνυμα. 
Το σημαντικό της συνάρτησης είναι το strcmp(rec1->surname, rec2->surname) &gt; 0 το οποίο λειτουργεί ως έξης: 
Αν ο αριθμός είναι αρνητικός, σημαίνει ότι το rec1->surname έρχεται πριν το rec2->surname 
Αν ο αριθμός είναι μηδενικός, σημαίνει ότι τα rec1->surname και rec2->surname είναι ίδια 
Αν ο αριθμός είναι θετικός, σημαίνει ότι το rec1->surname έρχεται μετά το rec2->surname 

  

sort_FileInChunks 
H συνάρτηση για αρχή δημιουργεί έναν CHUNK_Iterator που χρησιμοποιείται για να διασχίσει τα chunks του αρχείου. 
Μετά ελέγχει αν κλήση της συνάρτησης CHUNK_GetNext είναι επιτυχής, δηλαδή αν μπορεί να ανακτήσει το επόμενο chunk από τον iterator . 
Αν μπορεί καλεί την sort_Chunk. 

  

sort_Chunk 

Η συνάρτηση υλοποιεί την buble sort. 
To σημαντικό κομμάτι είναι στα σημεία: 
CHUNK_GetIthRecordInChunk(chunk, j + 1, &record1); CHUNK_GetIthRecordInChunk(chunk, j + 2, &record2); 
Οι λήψεις των εγγραφών στις θέσεις j + 1 και j + 2 γίνονται για να συγκρίνονται διαδοχικά οι εγγραφές στον inner loop. 
Όσο αυτές οι δύο εγγραφές συγκρίνονται χρησιμοποιείται η συνάρτηση shouldSwap για να καθορίσουν εάν πρέπει να γίνει ανταλλαγή μεταξύ τους 
Αν η shouldSwap επιστρέψει true, τότε οι εγγραφές ανταλλάσσονται μεταξύ τους 

  

----------------------------------------------------------------------------------------------------------------------------------------------------------- 

MERGE 

Ο πινακας records in chunk δεν επιρεαζει το αποτελέσμα. 
 

merge: 

Η merge υλοποιεί τη φάση συγχώνευσης(merging). 
Παίρνει σαν είσοδο τον αριθμό των chunks , το μέγεθος των chunks, τον αριθμό των chunks που θα συγχωνεύονται ταυτόχρονα (bWay), 
και το file descriptor του νέου αρχείου εξόδου. 
Η συνάρτηση εκτελεί τη διαδικασία συγχώνευσης, διαχειρίζεται τα αντίστοιχα chunk δεδομένων και βάζει τα αποτελέσματα στο νέο αρχείο. 
Πιο συγκεκριμενα υπολογιζουμε ποσα loop χρειάζονται ετσι ωστε να συγχωνευτούν με bway chunks ολο το αρχειο περνώντας, 
ειδική περίπτωση για την τελευτεα loop στην οποια το μεγεθος ειναι αναμεσα 1-bway chunks(κατα πασα πιθανότητα λιγότερα απο ολες τις αλλες loops) 
Το σκεπτικό για να ξερουμε ποτε εχει τελειωσει ενα sort ανα bway chunk ειναι να αρχικοποιησουμε τον πινακα εγγραφων (μια θεση για καθε chunk που εχουμε ) και 
βαζοντας μια συμβολικη σταθερα στο record_id : NOT FOUND. 
Στο τελος με την βοηθεια αυτου του πινακα παίρνουμε καθε φορα την επομενη εγγραφη με την βοηθεια του chunk itterator με την οποια βρισκουμε την μικροτερη εγγραφη. 

  

findSmallestRecord: 
Η findSmallestRecord βρίσκει την εγγραφή με τη μικρότερη τιμή, χρησιμοποιώντας την συνάρτηση shouldSwap απο την sort. 
Χρησιμοποιείται κατά τη διάρκεια του merging για να επιλέξει την επόμενη εγγραφή που θα εισαχθεί στο νέο αρχείο, εξασφαλίζοντας την σωστή σειρά. 

  

IsEmpty: 
Η IsEmpty ελέγχει εάν ένας πίνακας εγγραφών είναι άδειος, δηλαδή αν όλα τα id των εγγραφων έχουν τιμή NOT_FOUND. 
Χρησιμοποιείται για να ελέγχει εάν ένας πίνακας εγγραφών είναι άδειος κατά τη διάρκεια του συγχωνευτικού βήματος, για να αποφασίσει αν έχουν εξαντληθεί όλες οι εγγραφές των chunk που εχουμε την δεδομενη στιγμη στα χερια μας. 

  

------------------------------------------------------------------------------------------------------------------------------------------------------------- 

MAIN() 
Στην main() απλα κανουμε sort τα αρχει μετα merge και τα εκτυπώνουμε 
Έχουμε αποθηκεύσει σε μια global μεταβλιτη το ονομα του αρχειου ετσι ωστε να γινει εκτυπωση 
