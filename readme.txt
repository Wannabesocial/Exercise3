Για την δημιουργία του εκτελέσιμου το οποίο δείχνει
τις δυνατότητες της βιβλιοθήκης BF, τρέξτε την εντολή:

make sort;

Για να τρέξετε το εκτελέσιμο:

./build/sort_main


chunk.c and chunk.h:
STRUCTS
1.CHUNK το αφοισα οπος ηταν
2.CHUNK_Iterator εδω αποθικευω το file descriptor και εναν ακαιρεο που μου λεει σε πιο chunk βρισκομε

Γενικα εχω φτιαξει μια global μεταβλιτη απο CHUNKS(πανακας απο CHUNKS) στο chunk.c οπος και μια μεταβλιτη για το μεγεθος του πινακα αν και ειναι κακια πρακτικη να εχουμε global μεταβλητες το εκανα ετσει οστε να μην μπορεις καπιος να εχει προσβασει και να μπορει να αλαζει τα δεδωμενα που εχω μεσα στα chunks

FUNCTIONS
1.Δικες μου
α.void SetCHUNK(int from_BlockId,int to_BlockId,int recordsInChunk,int blocksInChunk,CHUNK *chunkModifed)
    Το μονο που κανει ειναι να αποθικευει στο CHUNK που του στελνο τις μεταβλιτες του

β.int Arraysize();
    Απλα επιστρεφη το ποσα chunks εχω φτιαξει



2.Προηπαρχουσες
α.CHUNK_Iterator CHUNK_CreateIterator(int fileDesc, int blocksInChunk);
    Αρχικα βρισκο ακριβος ποσα CHUNKS θα χριαστο.Αρχικοποιο τις μεταβλιτες του CHUNK ITERATOR και μετα αποδεσμευω τιχον χορο που ειχα δεσμευση πιο παλια για τα CHUNKS και μετα δεσμευω οσο χριαζομαι.Αρχικοποιο καθε ενα CHUNK ξεχοριστα.Για το τελευτεο ειμαι λιγο πιο προσεκτικος

β.int CHUNK_GetNext(CHUNK_Iterator *iterator,CHUNK* chunk);
    Ελενχο για αρχι αν βρισκομαι ειδι στο τελευτεο CHUNK του γραφο ενα μινιμα λαθους και επιστρεφο 1(αποτιχια) και εχει απλα το τελευταιο CHUNK ξανα στα χερια του.Αλιος αντιγραφο τα δεδωμενα και τα επιστρεφο στο τελος αλαζο την μεταβλιτη για τον επομενο CHUNK (ουσιαστικα στην προτη κλιση αυτη η συναρτιση επιστρεφη τα δεδωμενα του CHUNK[0]) και 0(επιτιχια).

γ.CHUNK_RecordIterator CHUNK_CreateRecordIterator(CHUNK *chunk);
    Φτιαχνο ενα iterator και το αρχικοποιο με τα δεδομενα που μου στελνει για το σιγκεκριμενο CHUNK

δ.int CHUNK_GetNextRecord(CHUNK_RecordIterator *iterator,Record* record);
    Ελενχο αν η εγγραφη που μου ζιταει να επιστρεψο υπαρχει,διλαδι αν πχ υπαρχουν 50 και μου ζιταει την εγγραφι πανο απο 51,αλιος του επιστρεφο την επομενη εγγραφη η οποια ειναι η τελευταιο απο την προηγουμενη φορα (διλαδι την προτη φορα που την καλλο επιστρεφη την προτη-προτη εγγραφη)

ε.void CHUNK_Print(CHUNK chunk);
    Φτιαχνο εναν Record Iterator για να εχω μια ευκολη προσβαση στης εγγραφης του CHUNK,εκτιπωνω καπια δεδωμενα για το CHUNK και μετα εκειπονο με ενα κομψο τροπο τις εγγραφες του CHUNK

--------------------------------------------------------------------------------------------------------------------

sort.c

shouldSwap
Στην shouldSwap ελέγχω αν δυο έγγραφες χρειάζεται να ανταλλαχτούν κατά την διάρκεια της ταξινόμησης.
Χρησιμοποιώντας την strcmp(rec1->name, rec2->name) ελέγχω  αν τα ονόματα είναι ίδια
Αν είναι τότε συγκρίνω επώνυμα.
Το σημαντικό της συνάρτησης είναι το strcmp(rec1->surname, rec2->surname) > 0 το οποίο λειτουργεί ως έξης:
Αν ο αριθμός είναι αρνητικός, σημαίνει ότι το rec1->surname έρχεται πριν το rec2->surname
Αν ο αριθμός είναι μηδενικός, σημαίνει ότι τα rec1->surname και rec2->surname είναι ίδια
Αν ο αριθμός είναι θετικός, σημαίνει ότι το rec1->surname έρχεται μετά το rec2->surname

sort_FileInChunks


H συνάρτηση για αρχή δημιουργεί έναν CHUNK_Iterator που χρησιμοποιείται για να διασχίσει τα chunks του αρχείου.

Μετά ελέγχει αν κλήση της συνάρτησης CHUNK_GetNext είναι επιτυχής, δηλαδή αν μπορεί να ανακτήσει το επόμενο  chunk από τον iterator .
Αν μπορεί καλεί την sort_Chunk.

sort_Chunk

Η συνάρτηση υλοποιεί την buble sort.
To σημαντικό κομμάτι είναι στα σημεία:             
    CHUNK_GetIthRecordInChunk(chunk, j + 1, &record1); CHUNK_GetIthRecordInChunk(chunk, j + 2, &record2);
Οι λήψεις των εγγραφών στις θέσεις j + 1 και j + 2 γίνονται για να συγκρίνονται διαδοχικά οι εγγραφές στον inner loop.
Όσο αυτές οι δύο εγγραφές συγκρίνονται χρησιμοποιείται η συνάρτηση shouldSwap για να καθορίσουν εάν πρέπει να γίνει ανταλλαγή μεταξύ τους
Αν η shouldSwap επιστρέψει true, τότε οι εγγραφές ανταλλάσσονται μεταξύ τους

MERGE

merge:
Η merge υλοποιεί τη φάση συγχώνευσης(merging). 
Παίρνει σαν είσοδο τον αριθμό των κομματιών (chunks), το μέγεθος των κομματιών, τον αριθμό των κομματιών που θα συγχωνεύονται ταυτόχρονα (bWay), 
και το file descriptor του νέου αρχείου εξόδου. 
Η συνάρτηση εκτελεί τη διαδικασία συγχώνευσης, διαχειρίζεται τα αντίστοιχα κομμάτια δεδομένων και βάζει τα αποτελέσματα στο νέο αρχείο.

findSmallestRecord:
Η findSmallestRecord βρίσκει την εγγραφή με τη μικρότερη τιμή, χρησιμοποιώντας την συνάρτηση shouldSwap απο την sort. 
Χρησιμοποιείται κατά τη διάρκεια του merging για να επιλέξει την επόμενη εγγραφή που θα εισαχθεί στο νέο αρχείο, εξασφαλίζοντας την σωστή σειρά.

IsEmpty:
Η IsEmpty ελέγχει εάν ένας πίνακας εγγραφών είναι άδειος, δηλαδή αν όλες οι εγγραφές έχουν τιμή NOT_FOUND. 
Χρησιμοποιείται για να ελέγχει εάν ένας πίνακας εγγραφών είναι άδειος κατά τη διάρκεια του συγχωνευτικού βήματος, για να αποφασίσει αν έχουν εξαντληθεί όλες οι εγγραφές στον πίνακα.